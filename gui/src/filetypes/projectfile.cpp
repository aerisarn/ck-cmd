#include "projectfile.h"
#include "behaviorfile.h"
#include "characterfile.h"
#include "skeletonfile.h"

#include "src/ui/genericdatawidgets.h"
#include "src/animData/skyrimanimationmotiondata.h"
#include "src/animData/skyrimanimdata.h"
#include "src/animSetData/skyrimanimsetdata.h"
#include "src/animSetData/hkcrc.h"
#include "src/xml/hkxxmlreader.h"
#include "src/xml/hkxxmlwriter.h"
#include "src/ui/mainwindow.h"
#include "src/hkxclasses/behavior/modifiers/hkbmodifier.h"
#include "src/hkxclasses/behavior/hkbprojectdata.h"
#include "src/hkxclasses/behavior/hkbprojectstringdata.h"
#include "src/hkxclasses/behavior/hkbcharacterstringdata.h"
#include "src/hkxclasses/hkrootlevelcontainer.h"
#include "src/hkxclasses/behavior/generators/hkbclipgenerator.h"
#include "src/hkxclasses/behavior/generators/hkbbehaviorreferencegenerator.h"
#include "src/hkxclasses/behavior/hkbfootikdriverinfo.h"
#include "src/hkxclasses/behavior/hkbhandikdriverinfo.h"
#include "src/hkxclasses/behavior/hkbcharacterdata.h"

#include <mutex>
#include <thread>

using namespace UI;

ProjectFile::ProjectFile(MainWindow *window, const QString & name, bool autogeneratedata, const QString &relativecharacterfilepath)
    : HkxFile(window, name),
      largestRef(0),
      projectIndex(-1),
      character(nullptr),
      skyrimAnimData(new SkyrimAnimData),
      skyrimAnimSetData(new SkyrimAnimSetData)
{
    projectName = getFileName().remove(".hkx");
    projectFolderName = fileName().section("/", -2, -2);
    projectAnimationsPath = "meshes/actors/"+projectFolderName+"/animations";
    getReader().setFile(this);
	getBinaryHandler().setFile(this);
    if (autogeneratedata && relativecharacterfilepath != ""){
        auto root = new UI::hkRootLevelContainer(this);
        root->addVariant("hkbProjectData", new hkbProjectData(this, 0, new hkbProjectStringData(this, 0, relativecharacterfilepath)));
        setRootObject(HkxSharedPtr(root));
        //setIsChanged(true);
    }
}

void ProjectFile::setCharacterFile(CharacterFile *file){
    //std::lock_guard <std::mutex> guard(mutex);
    character = file;
}

bool ProjectFile::isClipGenNameTaken(const QString &name) const{
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        if (behaviorFiles.at(i)->isClipGenNameTaken(name)){
            return true;
        }
    }
    return false;
}

bool ProjectFile::readAnimationData(const QString & filename, const QStringList & behaviorfilenames){
    //std::lock_guard <std::mutex> guard(mutex);
    auto result = false;
    if (skyrimAnimData){
        auto animfile = new QFile(filename);
        auto projectname = getFileName();
        if (!animfile->exists()){
            delete animfile;
            animfile = new QFile(QDir::currentPath()+"/animationdatasinglefile.txt");
            (!animfile->exists()) ? LogFile::writeToLog("'animationdatasinglefile.txt' is missing from the application directory!") : NULL;
        }
        (!behaviorfilenames.isEmpty()) ? result = skyrimAnimData->parse(animfile, projectname, behaviorfilenames) : result = skyrimAnimData->parse(animfile);
        (!result) ? LogFile::writeToLog(": The project animation data file could not be parsed!!!") : NULL;
        delete animfile;
        projectIndex = skyrimAnimData->getProjectIndex(projectname);
    }else{
        LogFile::writeToLog(": 'skyrimAnimData' is nullptr!!!");
    }
    return result;
}

bool ProjectFile::readAnimationSetData(const QString & filename){
    //std::lock_guard <std::mutex> guard(mutex);
    auto result = false;
    if (skyrimAnimData && skyrimAnimSetData){
        auto animsetfile = new QFile(QString(filename).replace("animationdatasinglefile.txt", "animationsetdatasinglefile.txt"));
        if (!animsetfile->exists()){
            delete animsetfile;
            animsetfile = new QFile(QDir::currentPath()+"/animationsetdatasinglefile.txt");
            (!animsetfile->exists()) ? LogFile::writeToLog(": 'animationsetdatasinglefile.txt' is missing from the application directory!") : NULL;
        }
        (!skyrimAnimSetData->parse(animsetfile)) ? LogFile::writeToLog(": The project animation set data file could not be parsed!!!") : result = true;
        delete animsetfile;
    }else{
        LogFile::writeToLog(": 'skyrimAnimData' or 'skyrimAnimSetData' are nullptr!!!");
    }
    return result;
}

bool ProjectFile::removeClipGenFromAnimData(const QString & animationname, const QString & clipname, const QString & variablename){
    //std::lock_guard <std::mutex> guard(mutex);
    auto result = false;
    if (skyrimAnimData && skyrimAnimSetData){
        result = skyrimAnimData->removeClipGenerator(projectName+".txt", clipname);
        skyrimAnimSetData->removeAnimationFromCache(projectName+".txt", animationname, variablename, clipname);
    }else{
        LogFile::writeToLog(": 'skyrimAnimData' or 'skyrimAnimSetData' are nullptr!!!");
    }
    return result;
}

bool ProjectFile::removeAnimationFromAnimData(const QString &name){
    //std::lock_guard <std::mutex> guard(mutex);
    auto result = false;
    if (skyrimAnimData && character){
        return skyrimAnimData->removeAnimation(projectName+".txt", character->getAnimationNames().indexOf(name));
    }else{
        LogFile::writeToLog(": 'skyrimAnimData' or 'character' are nullptr!!!");
    }
    return result;
}


QString ProjectFile::getCharacterFilePathAt(int index) const{
    //std::lock_guard <std::mutex> guard(mutex);
    QString path;
    (stringData.data()) ? path = static_cast<hkbProjectStringData *>(stringData.data())->getCharacterFilePathAt(index) : LogFile::writeToLog(":'stringData' is nullptr!");
    return path;
}

HkxSharedPtr * ProjectFile::findProjectData(long ref){
    //std::lock_guard <std::mutex> guard(mutex);
    if (projectData.getShdPtrReference() == ref){
        return &projectData;
    }
    return nullptr;
}

HkxSharedPtr * ProjectFile::findProjectStringData(long ref){
    //std::lock_guard <std::mutex> guard(mutex);
    if (stringData.getShdPtrReference() == ref){
        return &stringData;
    }
    return nullptr;
}

bool ProjectFile::addObjectToFile(HkxObject *obj, long ref){
    ////std::lock_guard <std::mutex> guard(mutex);
    if (obj){
        (ref > largestRef) ? largestRef = ref : largestRef++;
        obj->setReference(largestRef);
        if (obj->getSignature() == HKB_PROJECT_DATA){
            projectData = HkxSharedPtr(obj, ref);
        }else if (obj->getSignature() == HKB_PROJECT_STRING_DATA){
            stringData = HkxSharedPtr(obj, ref);
        }else if (obj->getSignature() == HK_ROOT_LEVEL_CONTAINER){
            setRootObject(HkxSharedPtr(obj, ref));
        }else{
            LogFile::writeToLog("ProjectFile: addObjectToFile() failed!\nInvalid type enum for this object!\nObject signature is: "+QString::number(obj->getSignature(), 16));
            return false;
        }
        return true;
    }
    return false;
}

bool ProjectFile::parseBinary() {
	std::lock_guard <std::mutex> guard(mutex);
	auto& handler = getBinaryHandler();
	auto appendnread = [&](HkxObject * dest, const QString & nameoftype, const void * source) {
		if (!dest->readData(handler, source)) {
			LogFile::writeToLog("ProjectFile: parse(): Failed to read a " + nameoftype + " object! Ref: " + QString::number(dest->ref));
		}
	};
	if (handler.parse()) {
		size_t elements = handler.getNumElements();
		if (elements < 3)
			return false;
		for (size_t i = 0; i < elements; i++) {
			printf("%d\n", i);
			const auto* hkclass = handler.getElementClass(i);
			const void* obj = handler.getElementObject(i);
			printf("%s\n", hkclass->getName());
			switch (hkclass->getSignature())
			{
				case HKB_PROJECT_DATA:
					appendnread(new hkbProjectData(this, i), "HKB_PROJECT_DATA", obj); break;
				case HKB_PROJECT_STRING_DATA:
					new hkbProjectStringData(this, i);
					appendnread(new hkbProjectStringData(this, i), "HKB_PROJECT_STRING_DATA", obj); break;
				case HK_ROOT_LEVEL_CONTAINER:
					appendnread(new UI::hkRootLevelContainer(this, i), "HK_ROOT_LEVEL_CONTAINER", obj); break;
				default:
					LogFile::writeToLog(fileName() + ": Unknown signature detected! Unknown object class name is: " + hkclass->getName() + " Unknown object signature is: " + QString::number(hkclass->getSignature(), 16));
				
			}
		}
		closeFile();
		getBinaryHandler().clear();
		if (link()) return true; 
		LogFile::writeToLog(fileName() + ": failed to link!!!");		
	}
	return false;
}

bool ProjectFile::parse(){
    //std::lock_guard <std::mutex> guard(mutex);
    auto index = 2L;
    auto ok = false;
    HkxSignature signature;
    QByteArray value;
    auto ref = 0;
    auto appendnread = [&](HkxObject *obj, const QString & nameoftype){
        (!appendAndReadData(index, obj)) ? LogFile::writeToLog("BehaviorFile: parse(): Failed to read a "+nameoftype+" object! Ref: "+QString::number(ref)) : NULL;
    };
    if (getReader().parse()){
        for (; index < getReader().getNumElements(); index++){
            value = getReader().getNthAttributeNameAt(index, 1);
            if (value == "class"){
                value = getReader().getNthAttributeValueAt(index, 2);
                if (value != ""){
                    ref = getReader().getNthAttributeValueAt(index, 0).remove(0, 1).toLong(&ok);
                    (!ok) ? LogFile::writeToLog("BehaviorFile: parse() failed! The object reference string contained invalid characters and failed to convert to an integer!") : NULL;
                    signature = (HkxSignature)value.toULongLong(&ok, 16);
                    (!ok) ? LogFile::writeToLog("BehaviorFile: parse() failed! The object signature string contained invalid characters and failed to convert to an integer!") : NULL;
                    switch (signature){
                    case HKB_PROJECT_DATA:
                        appendnread(new hkbProjectData(this, ref), "HKB_PROJECT_DATA"); break;
                    case HKB_PROJECT_STRING_DATA:
                        appendnread(new hkbProjectStringData(this, ref), "HKB_PROJECT_STRING_DATA"); break;
                    case HK_ROOT_LEVEL_CONTAINER:
                        appendnread(new UI::hkRootLevelContainer(this, ref), "HK_ROOT_LEVEL_CONTAINER"); break;
                    default:
                        LogFile::writeToLog(fileName()+": Unknown signature detected! Unknown object class name is: "+getReader().getNthAttributeValueAt(index, 1)+" Unknown object signature is: "+QString::number(signature, 16));
                    }
                }
            }
        }
        closeFile();
        getReader().clear();
        (link()) ? ok = true : LogFile::writeToLog(fileName()+": failed to link!!!");
    }else{
        LogFile::writeToLog(fileName()+": failed to parse!!!");
    }
    return ok;
}

bool ProjectFile::link(){
    if (!getRootObject().constData()){
        LogFile::writeToLog("ProjectFile: link() failed!\nThe root object of this project file is nullptr!");
        return false;
    }else if (getRootObject()->getSignature() != HK_ROOT_LEVEL_CONTAINER){
        LogFile::writeToLog("ProjectFile: link() failed!\nThe root object of this project file is NOT a hkRootLevelContainer!\nThe root object signature is: "+QString::number(getRootObject()->getSignature(), 16));
        return false;
    }
    if (!getRootObject()->link()){
        LogFile::writeToLog("ProjectFile: link() failed!\nThe root object of this project file failed to link to it's children!");
        return false;
    }
    if (!projectData.data() || !projectData->link()){
        LogFile::writeToLog("ProjectFile: link() failed!\nprojectData failed to link to it's children!");
        return false;
    }
    return true;
}

void ProjectFile::addFootIK(){
    //std::lock_guard <std::mutex> guard(mutex);
    (character) ? character->addFootIK() : LogFile::writeToLog(":'character' is nullptr!");
}

void ProjectFile::disableHandIK(){
    //std::lock_guard <std::mutex> guard(mutex);
    (character) ? character->disableHandIK() : LogFile::writeToLog(":'character' is nullptr!");
}

void ProjectFile::disableFootIK(){
    //std::lock_guard <std::mutex> guard(mutex);
    (character) ? character->disableFootIK() : LogFile::writeToLog(":'character' is nullptr!");
}

void ProjectFile::addHandIK(){
    //std::lock_guard <std::mutex> guard(mutex);
    (character) ? character->addHandIK() : LogFile::writeToLog(":'character' is nullptr!");
}

hkbHandIkDriverInfo *ProjectFile::getHandIkDriverInfo() const{
    //std::lock_guard <std::mutex> guard(mutex);
    hkbHandIkDriverInfo *handdriver = nullptr;
    (character) ? handdriver = static_cast<hkbHandIkDriverInfo *>(character->getHandIkDriverInfo().data()) : LogFile::writeToLog(":'character' is nullptr!");
    return handdriver;
}

hkbFootIkDriverInfo *ProjectFile::getFootIkDriverInfo() const{
    //std::lock_guard <std::mutex> guard(mutex);
    hkbFootIkDriverInfo *footdriver = nullptr;
    (character) ? footdriver = static_cast<hkbFootIkDriverInfo *>(character->getFootIkDriverInfo().data()) : LogFile::writeToLog(":'character' is nullptr!");
    return footdriver;
}

hkaSkeleton *ProjectFile::getSkeleton(bool isragdoll) const{
    //std::lock_guard <std::mutex> guard(mutex);
    hkaSkeleton *skel = nullptr;
    (character) ? skel = character->getSkeleton(isragdoll) : LogFile::writeToLog(":'character' is nullptr!");
    return skel;
}

ProjectAnimData *ProjectFile::getAnimDataAt(const QString & projectname) const{
    //std::lock_guard <std::mutex> guard(mutex);
    ProjectAnimData *animdata = nullptr;
    (skyrimAnimData) ? animdata = skyrimAnimData->getProjectAnimData(projectname) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
    return animdata;
}

HkxObject *ProjectFile::getCharacterStringData() const{
    //std::lock_guard <std::mutex> guard(mutex);
    HkxObject *obj = nullptr;
    (character) ? obj = character->getCharacterStringData() : LogFile::writeToLog(":'character' is nullptr!");
    return obj;
}

HkxObject *ProjectFile::getCharacterData() const{
    //std::lock_guard <std::mutex> guard(mutex);
    HkxObject *obj = nullptr;
    (character) ? obj = character->getCharacterData() : LogFile::writeToLog(":'character' is nullptr!");
    return obj;
}

QString ProjectFile::detectErrorsInProject(){
    //std::lock_guard <std::mutex> guard(mutex);
    ProgressDialog progress("Detecting possible errors...", "", 0, 100, getUI());
    progress.setWindowModality(Qt::WindowModal);
    std::vector <std::future<QString>> futures;
    auto percent = 0;
    auto numbehaviors = behaviorFiles.size();
    auto taskCount = numbehaviors;
    auto previousCount = taskCount;
    auto fileIndex = 0;
    auto maxThreads = std::thread::hardware_concurrency() - 1;
    auto taskdifference = 0;
    qreal difference = ((1.0)/((qreal)(numbehaviors)))*(100.0);
    /*std::unique_lock<std::mutex> locker(mutex);
    for (uint i = 0; i < maxThreads, fileIndex < numbehaviors; i++, fileIndex++){
        futures.push_back(std::async(std::launch::async, &BehaviorFile::detectErrorsMT, behaviorFiles.at(fileIndex), std::ref(taskCount), std::ref(mutex), std::ref(conditionVar)));
    }
    while (taskCount > 0){
        if (taskCount < numbehaviors){
            percent += difference;
            progress.setValue(percent);
        }
        taskdifference = previousCount - taskCount;
        previousCount = taskCount;
        for (; taskdifference > 0; taskdifference--){
            if (fileIndex < numbehaviors){
                futures.push_back(std::async(std::launch::async, &BehaviorFile::detectErrorsMT, behaviorFiles.at(fileIndex), std::ref(taskCount), std::ref(mutex), std::ref(conditionVar)));
                fileIndex++;
            }
        }
        conditionVar.wait(locker, [&](){return (taskCount < previousCount);});
    }
    QString errorstring("\n\n");
    for (auto i = 0; i < futures.size(); i++){
        errorstring = errorstring + futures.at(i).get();
    }*/
    QString errorstrings;
    for (auto i = 0; i < behaviorFiles.size(); i++){
        errorstrings = errorstrings + behaviorFiles.at(i)->detectErrors();
    }
    return errorstrings+"\nCheck 'DebugLog.txt' in the application directory for details...";
}

QString ProjectFile::detectErrorsInBehavior(const QString &filename){
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        if (!behaviorFiles.at(i)->fileName().compare(filename, Qt::CaseInsensitive)){
            return behaviorFiles.at(i)->detectErrors();
        }
    }
    LogFile::writeToLog("ProjectFile::detectErrorsInBehavior(): Project not found!");
    return "";
}

void ProjectFile::removeUnreferencedFiles(const hkbBehaviorReferenceGenerator *gentoignore){
    //std::lock_guard <std::mutex> guard(mutex);
    QStringList filestoremove;
    QStringList referencedbehaviors;
    QVector <int> behaviorindices;
    auto rootbehaviorname = character->getRootBehaviorFilename().toLower();
    for (auto i = 0; i < behaviorFiles.size(); i++){
        if (behaviorFiles.at(i)->fileName().toLower().section("/", -1, -1) == rootbehaviorname){
            behaviorindices.append(i);
        }else{
            filestoremove.append(behaviorFiles.at(i)->fileName());
        }
    }
    for (auto i = 0; i < behaviorindices.size(); i++){
        referencedbehaviors = behaviorFiles.at(behaviorindices.at(i))->getReferencedBehaviors(gentoignore);
        for (auto j = 0; j < referencedbehaviors.size(); j++){
            for (auto k = filestoremove.size() - 1; k > -1; k--){
                if (!QString::compare(QString(referencedbehaviors.at(j)).replace("\\", "/"), filestoremove.at(k).section("/", -1, -1), Qt::CaseInsensitive)){
                    for (auto l = 0; l < behaviorFiles.size(); l++){
                        if (behaviorFiles.at(l)->fileName() == filestoremove.at(k)){
                            behaviorindices.append(l);
                            filestoremove.removeAt(k);
                            k = -1;
                            l = behaviorFiles.size();
                        }
                    }
                }
            }
        }
    }
    getUI()->removeBehaviorGraphs(filestoremove);
    for (auto i = filestoremove.size() - 1; i > -1; i--){
        skyrimAnimData->removeBehaviorFromProject(projectName, filestoremove.at(i));
    }
}

void ProjectFile::ensureAllRefedAnimationsExist(){
    //std::lock_guard <std::mutex> guard(mutex);
    if (character && !behaviorFiles.isEmpty()){
        auto animations = character->getAnimationNames();
        QStringList refedAnimations;
        for (auto i = 0; i < behaviorFiles.size(); i++){
            refedAnimations = refedAnimations + behaviorFiles.at(i)->getRefedAnimations();
        }
        for (auto i = 0; i < refedAnimations.size(); i++){
            if (!animations.contains(refedAnimations.at(i), Qt::CaseInsensitive)){
                character->addAnimation(refedAnimations.at(i));
            }
        }
    }
}

bool ProjectFile::merge(ProjectFile *recessiveproject, bool isFNIS){ //Make sure to update event and variable indices when merging!!!
    //std::lock_guard <std::mutex> guard(mutex);
    auto value = false;
    bool found;
    if (recessiveproject){
        QVector <BehaviorFile *> dominantbehaviors(behaviorFiles);
        QVector <BehaviorFile *> recessivebehaviors(recessiveproject->behaviorFiles);
        QVector <DataIconManager *> objectsnotfound;
        if (isFNIS){
            recessiveproject->character->merge(character);
            auto name = character->fileName();
            if (!character->remove()){
                LogFile::writeToLog("failed to remove character file");
            }
            character = recessiveproject->character;
            character->setHKXFileName(name);
        }else{
            character->merge(recessiveproject->character);
        }
        if (!QString::compare(projectName, recessiveproject->projectName, Qt::CaseInsensitive)){
            ProgressDialog progress("Merging projects...", "", 0, 100, getUI(), Qt::Dialog);
            progress.setWindowModality(Qt::WindowModal);
            auto percent = 0;
            qreal difference = ((1.0)/((qreal)(dominantbehaviors.size())))*(100.0);
            for (auto i = 0; i < dominantbehaviors.size(); i++){
                for (auto j = 0; j < recessivebehaviors.size(); j++){
                    if (!QString::compare(dominantbehaviors.at(i)->getFileName(), recessivebehaviors.at(j)->getFileName(), Qt::CaseInsensitive)){
                        objectsnotfound = objectsnotfound + dominantbehaviors.at(i)->merge(recessivebehaviors.at(j));
                        percent += difference;
                        progress.setValue(percent);
                    }
                }
            }
            percent = 0;
            progress.setProgress("Merging loose objects...", percent);
            difference = ((1.0)/((qreal)(dominantbehaviors.size())))*(100.0);
            for (auto k = dominantbehaviors.size() - 1; k >= 0 && !objectsnotfound.isEmpty(); k--){ //need to cycle backwards to prevent jump/horsebehavior merge bug...
                dominantbehaviors.at(k)->mergeObjects(objectsnotfound);
                percent += difference;
                progress.setValue(percent);
            }
            percent = 0;
            progress.setProgress("Adding surplus files to the dominant project...", percent);
            difference = ((1.0)/((qreal)(recessivebehaviors.size())))*(100.0);
            value = true;
            for (auto i = 0; i < recessivebehaviors.size(); i++){
                found = false;
                for (auto j = 0; j < behaviorFiles.size(); j++){
                    if (!QString::compare(behaviorFiles.at(j)->getFileName(), recessivebehaviors.at(i)->getFileName(), Qt::CaseInsensitive)){
                        found = true;
                    }
                }
                if (!found){
                    recessivebehaviors.at(i)->setHKXFileName(fileName().section("/", 0, -2)+"/behaviors/"+recessivebehaviors.at(i)->getFileName());
                    behaviorFiles.append(recessivebehaviors.at(i));
                    percent += difference;
                    progress.setValue(percent);
                }
            }
            percent = 0;
            progress.setProgress("Merging animation caches...", percent);
            /*if (!mergeAnimationCaches(recessiveproject)){
                LogFile::writeToLog("ProjectFile: merge() failed!\nmergeAnimationCaches() failed!");
            }*/
            progress.setProgress("Done!!!", progress.maximum());
        }else{
            LogFile::writeToLog("ProjectFile: merge() failed!\nProject names are different!");
        }
    }else{
        LogFile::writeToLog("ProjectFile: merge() failed!\nrecessiveproject is nullptr!");
    }
    return value;
}

bool ProjectFile::mergeAnimationCaches(ProjectFile *recessiveproject){  //TO DO: Need to check each animation index with animation name and inject if not found???
    //std::lock_guard <std::mutex> guard(mutex);
    if (recessiveproject){
        if (skyrimAnimSetData && recessiveproject->skyrimAnimSetData){
            if (skyrimAnimSetData->mergeAnimationCaches(projectName, recessiveproject->projectName, recessiveproject->skyrimAnimSetData)){
                return true;
            }
        }else{
            LogFile::writeToLog("ProjectFile: merge() failed!\n skyrimAnimSetData or recessiveproject->skyrimAnimSetData is nullptr!");
        }
    }else{
        LogFile::writeToLog("ProjectFile: merge() failed!\nrecessiveproject is nullptr!");
    }
    return false;
}

void ProjectFile::addProjectToAnimData(){
    //std::lock_guard <std::mutex> guard(mutex);
    if (skyrimAnimSetData && skyrimAnimData){
        QStringList projectfiles;
        projectfiles.append(behaviorFiles.first()->fileName().section("/", -2, -1).replace("/", "\\"));
        projectfiles.append(character->fileName().section("/", -2, -1).replace("/", "\\"));
        projectfiles.append("character assets\\"+character->getSkeletonFileName().replace("/", "\\"));
        auto index = skyrimAnimData->addNewProject(projectName+".txt", projectfiles);
        (index == -1) ? LogFile::writeToLog(": Project: "+projectName+".txt"+" already exists in the animation data!!!") : projectIndex = index;
        if (!skyrimAnimSetData->addNewProject(projectName+"ProjectData\\"+projectName+".txt")){
            LogFile::writeToLog(": Project: "+projectName+".txt"+" failed to append to the animation set data!!!");
        }
    }else{
        LogFile::writeToLog(": 'skyrimAnimData' or 'skyrimAnimSetData' are nullptr!!!");
    }
}

AnimCacheProjectData *ProjectFile::getProjectCacheData() const{
    //std::lock_guard <std::mutex> guard(mutex);
    AnimCacheProjectData *projdata = nullptr;
    (skyrimAnimSetData) ? projdata = skyrimAnimSetData->getProjectCacheData(projectName) : LogFile::writeToLog(":'skyrimAnimSetData' is nullptr!!!");
    return projdata;
}

void ProjectFile::setAnimationIndexDuration(int indexofanimationlist, int animationindex, qreal duration){
    //std::lock_guard <std::mutex> guard(mutex);
    auto project = skyrimAnimData->getProjectAnimData(projectName);
    if (project){
        if (indexofanimationlist == -1){
            project->animationMotionData.last()->setAnimationIndex(animationindex);
            project->animationMotionData.last()->setDuration(duration);
        }else if (indexofanimationlist < project->animationMotionData.size()){
            project->animationMotionData.at(indexofanimationlist)->setAnimationIndex(animationindex);
            project->animationMotionData.at(indexofanimationlist)->setDuration(duration);
        }
    }else{
        LogFile::writeToLog("'projectName' was not found in the animation data!");
    }
}

void ProjectFile::generateAnimClipDataForProject(){
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        for (auto j = 0; j < behaviorFiles.at(i)->generators.size(); j++){
            auto generator = behaviorFiles.at(i)->generators.at(j).data();
            if (generator->getSignature() == HKB_CLIP_GENERATOR){
                auto clipGenDataPtr = new SkyrimClipGeneratoData(static_cast<hkbClipGenerator *>(generator)->getClipGeneratorAnimData(skyrimAnimData->getProjectAnimData(projectName), getAnimationIndex(static_cast<hkbClipGenerator *>(generator)->getAnimationName())));
                if (!skyrimAnimData->appendClipGenerator(projectName, clipGenDataPtr)){
                    //LogFile::writeToLog((QString("ProjectFile::generateAnimDataForProject(): Duplicate clip generator \""+clipGenDataPtr->getClipGeneratorName()+"found in: "+behaviorFiles.at(i)->getFileName())));
                }
            }
        }
    }
}

void ProjectFile::loadEncryptedAnimationNames(){
    //std::lock_guard <std::mutex> guard(mutex);
    auto list = getAnimationNames();
    for (auto i = 0; i < list.size(); i++){
        encryptedAnimationNames.append(QString(HkCRC().compute(list.at(i).section("\\", -1, -1).toLower().replace(".hkx", "").toLocal8Bit())));
    }
}

void ProjectFile::addEncryptedAnimationName(const QString &unencryptedname){
    //std::lock_guard <std::mutex> guard(mutex);
    QString animationhash = HkCRC().compute(unencryptedname.section("/", -1, -1).toLower().replace(".hkx", "").toLocal8Bit());
    bool ok;
    animationhash = QString::number(animationhash.toULong(&ok, 16));
    (ok) ? encryptedAnimationNames.append(animationhash) : LogFile::writeToLog(":Animation hash is invalid!!!");
}

void ProjectFile::removeEncryptedAnimationName(int index){
    //std::lock_guard <std::mutex> guard(mutex);
    (index > -1 && index < encryptedAnimationNames.size()) ? encryptedAnimationNames.removeAt(index) : LogFile::writeToLog(":Invalid 'encryptedAnimationNames' index!");
}

void ProjectFile::deleteBehaviorFile(const QString &filename){
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = behaviorFiles.size() - 1; i > -1; i--){
        if (filename == behaviorFiles.at(i)->fileName()){
            skyrimAnimData->removeBehaviorFromProject(projectName, behaviorFiles.at(i)->fileName().section("/", -2, -1).replace("/", "\\"));
            (!behaviorFiles.at(i)->remove()) ? LogFile::writeToLog(": File \""+behaviorFiles.at(i)->fileName()+"\" was not deleted from the file system!") : NULL;
            delete behaviorFiles.at(i);
            behaviorFiles.removeAt(i);
        }
    }
}

int ProjectFile::getAnimationIndex(const QString & name) const{
    //std::lock_guard <std::mutex> guard(mutex);
    auto index = -1;
    (character) ? index = character->getAnimationIndex(name) : LogFile::writeToLog(":'character' is nullptr!");
    return index;
}

bool ProjectFile::isAnimationUsed(const QString &animationname) const{
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        for (auto j = 0; j < behaviorFiles.at(i)->generators.size(); j++){
            auto generator = behaviorFiles.at(i)->generators.at(j).data();
            if (generator->getSignature() == HKB_CLIP_GENERATOR){
                if (!QString::compare(animationname, static_cast<hkbClipGenerator *>(generator)->getAnimationName(), Qt::CaseInsensitive)){
                    LogFile::writeToLog("ProjectFile: isAnimationUsed()!\nAnimation is used in the Clip Generator \""+static_cast<hkbClipGenerator *>(generator)->getName()+"\" in behavior: "+behaviorFiles.at(i)->fileName().section("/",-1,-1));
                    return true;
                }
            }
        }
    }
    return false;
}

QStringList ProjectFile::getAnimationNames() const{
    //std::lock_guard <std::mutex> guard(mutex);
    QStringList names;
    (character) ? names = character->getAnimationNames() : LogFile::writeToLog(":'character' is nullptr!");
    return names;
}

QString ProjectFile::findAnimationNameFromEncryptedData(const QString &encryptedname) const{
    //std::lock_guard <std::mutex> guard(mutex);
    auto ok = true;
    ULONGLONG value1;
    ULONGLONG value2 = encryptedname.toULongLong(&ok, 10);
    if (!ok){
        value2 = encryptedname.toULongLong(&ok, 16);
        (!ok) ? LogFile::writeToLog("ProjectFile::findAnimationNameFromEncryptedData(): encryptedname.toULong(&ok, 10) Failed!") : NULL;
    }
    for (auto i = 0; i < encryptedAnimationNames.size(); i++){
        value1 = encryptedAnimationNames.at(i).toULongLong(&ok, 16);
        (!ok) ? LogFile::writeToLog("ProjectFile::findAnimationNameFromEncryptedData(): encryptedAnimationNames.at(i).toULong(&ok, 16) Failed!") : NULL;
        if (value1 == value2){
            (!character) ? LogFile::writeToLog("ProjectFile::findAnimationNameFromEncryptedData(): character is nullptr!") : NULL;
            return character->getAnimationNameAt(i).toLower().section("\\", -1, -1).replace(".hkx", "");
        }
    }
    return "";
}

bool ProjectFile::isProjectNameTaken() const{
    //std::lock_guard <std::mutex> guard(mutex);
    auto value = false;
    (skyrimAnimData) ? value = skyrimAnimData->isProjectNameTaken(projectName) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
    return value;
}

QString ProjectFile::getProjectName() const{
    //std::lock_guard <std::mutex> guard(mutex);
    return projectName;
}

qreal ProjectFile::getAnimationDurationFromAnimData(const QString &animationname) const{
    //std::lock_guard <std::mutex> guard(mutex);
    qreal value = 0;
    (skyrimAnimData && character) ? value = skyrimAnimData->getAnimationDurationFromAnimData(projectName, character->getAnimationIndex(animationname)) : LogFile::writeToLog(":'skyrimAnimData' or 'character' are nullptr!");
    return value;
}

bool ProjectFile::appendAnimation(SkyrimAnimationMotionData *motiondata){
    //std::lock_guard <std::mutex> guard(mutex);
    auto value = false;
    (skyrimAnimData) ? value = skyrimAnimData->appendAnimation(projectName, motiondata) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
    return value;
}

SkyrimAnimationMotionData ProjectFile::getAnimationMotionData(int animationindex) const{
    //std::lock_guard <std::mutex> guard(mutex);
    SkyrimAnimationMotionData value(nullptr);
    (skyrimAnimData) ? value = skyrimAnimData->getAnimationMotionData(projectName, animationindex) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
    return value;
}

bool ProjectFile::isNameUniqueInProject(HkxObject *object, const QString &filenametoignore) const{
    //std::lock_guard <std::mutex> guard(mutex);
    if (object){
        if (object->getType() == HkxObject::TYPE_GENERATOR){
            for (auto i = 0; i < behaviorFiles.size(); i++){
                if (QString::compare(behaviorFiles.at(i)->fileName(), filenametoignore, Qt::CaseInsensitive)){
                    for (auto j = 0; j < behaviorFiles.at(i)->generators.size(); j++){
                        if (object->getSignature() == behaviorFiles.at(i)->generators.at(j)->getSignature() && static_cast<hkbGenerator *>(object)->getName() == static_cast<hkbGenerator *>(behaviorFiles.at(i)->generators.at(j).data())->getName()){
                            return false;
                        }
                    }
                }
            }
        }else if (object->getType() == HkxObject::TYPE_MODIFIER){
            for (auto i = 0; i < behaviorFiles.size(); i++){
                if (QString::compare(behaviorFiles.at(i)->fileName(), filenametoignore, Qt::CaseInsensitive)){
                    for (auto j = 0; j < behaviorFiles.at(i)->modifiers.size(); i++){
                        if (object->getSignature() == behaviorFiles.at(i)->modifiers.at(j)->getSignature() && static_cast<hkbModifier *>(object)->getName() == static_cast<hkbModifier *>(behaviorFiles.at(i)->modifiers.at(j).data())->getName()){
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}

bool ProjectFile::hasAnimData() const{
    //std::lock_guard <std::mutex> guard(mutex);
    auto value = false;
    if (skyrimAnimData){
        (!skyrimAnimData->isEmpty()) ? value = true : value = false;
    }
    return value;
}

bool ProjectFile::hasAnimSetData() const{
    //std::lock_guard <std::mutex> guard(mutex);
    auto value = false;
    if (skyrimAnimData){
        (!skyrimAnimData->isEmpty()) ? value = true : value = false;
    }
    return value;
}

void ProjectFile::writeOrderOfFiles() const{
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        LogFile::writeToLog("File at index "+QString::number(i)+" is "+behaviorFiles.at(i)->getFileName());
    }
}

hkbStateMachine *ProjectFile::findRootStateMachineFromBehavior(const QString behaviorname) const{
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        if (behaviorFiles.at(i)->fileName().contains(QString(behaviorname).replace("\\", "/"), Qt::CaseInsensitive)){
            return static_cast<hkbStateMachine *>(behaviorFiles.at(i)->getRootStateMachine());
        }
    }
    return nullptr;
}

QString ProjectFile::getBehaviorDirectoryName() const{
    //std::lock_guard <std::mutex> guard(mutex);
    QString name;
    (character) ? name = character->getBehaviorDirectoryName() : LogFile::writeToLog(": 'character' is nullptr!");
    return name;
}

QString ProjectFile::getProjectAnimationsPath() const{
    //std::lock_guard <std::mutex> guard(mutex);
    return projectAnimationsPath;
}

bool ProjectFile::appendClipGeneratorAnimData(const QString &name){
    //std::lock_guard <std::mutex> guard(mutex);
    auto value = false;
    (skyrimAnimData) ? value = skyrimAnimData->appendClipGenerator(projectName, new SkyrimClipGeneratoData(skyrimAnimData->getProjectAnimData(projectName), name)) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
    return value;
}

void ProjectFile::setLocalTimeForClipGenAnimData(const QString &clipname, int triggerindex, qreal time){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setLocalTimeForClipGenAnimData(projectName, clipname, triggerindex, time) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::setEventNameForClipGenAnimData(const QString &clipname, int triggerindex, const QString &eventname){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setEventNameForClipGenAnimData(projectName, clipname, triggerindex, eventname) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::setClipNameAnimData(const QString &oldclipname, const QString &newclipname){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setClipNameAnimData(projectName, oldclipname, newclipname) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::setAnimationIndexForClipGen(int index, const QString &clipGenName){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setAnimationIndexForClipGen(projectName, clipGenName, index) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::setPlaybackSpeedAnimData(const QString &clipGenName, qreal speed){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setPlaybackSpeedAnimData(projectName, clipGenName, speed) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::setCropStartAmountLocalTimeAnimData(const QString &clipGenName, qreal time){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setCropStartAmountLocalTimeAnimData(projectName, clipGenName, time) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::setCropEndAmountLocalTimeAnimData(const QString &clipGenName, qreal time){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->setCropEndAmountLocalTimeAnimData(projectName, clipGenName, time) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::appendClipTriggerToAnimData(const QString &clipGenName, const QString &eventname){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->appendClipTriggerToAnimData(projectName, clipGenName, eventname) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::removeClipTriggerToAnimDataAt(const QString &clipGenName, int index){
    //std::lock_guard <std::mutex> guard(mutex);
    (skyrimAnimData) ? skyrimAnimData->removeClipTriggerToAnimDataAt(projectName, clipGenName, index) : LogFile::writeToLog(":'skyrimAnimData' is nullptr!");
}

void ProjectFile::write(){
    //std::lock_guard <std::mutex> guard(mutex);
    if (stringData && projectData){
        ulong ref = 100;
        getRootObject()->setReference(ref);
        getRootObject()->setIsWritten(false);
        ref++;
        stringData->setReference(ref++);
        stringData->setIsWritten(false);
        projectData->setReference(ref++);
        projectData->setIsWritten(false);
        getWriter().setFile(this);
        getWriter().writeToXMLFile();
    }else{
        LogFile::writeToLog(":'stringData' or 'projectData' are nullptr!");
    }
}

void ProjectFile::writeBinary() {
	if (stringData && projectData) {
		getBinaryHandler().setFile(this);
		getBinaryHandler().writeToFile();
	}
	else {
		LogFile::writeToLog(":'stringData' or 'projectData' are nullptr!");
	}
}


bool ProjectFile::doesBehaviorExist(const QString &behaviorname) const{
    //std::lock_guard <std::mutex> guard(mutex);
    for (auto i = 0; i < behaviorFiles.size(); i++){
        if (behaviorFiles.at(i)->fileName().contains(behaviorname, Qt::CaseInsensitive)){
            return true;
        }
    }
    return false;
}

ProjectFile::~ProjectFile(){
    for (auto i = 0; i < behaviorFiles.size(); i++){
        (behaviorFiles.at(i)) ? delete behaviorFiles.at(i) : NULL;
    }
    (character) ? delete character : NULL;
    (skyrimAnimData) ? delete skyrimAnimData : NULL;
    (skyrimAnimSetData) ? delete skyrimAnimSetData : NULL;
}
